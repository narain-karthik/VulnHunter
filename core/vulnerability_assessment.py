"""
Vulnerability Assessment Phase - Automated vulnerability scanning and analysis
Handles the identification and classification of security vulnerabilities
"""

import os
import json
import subprocess
import requests
from datetime import datetime
from colorama import Fore, Style
from utils.output_formatter import OutputFormatter

class VulnerabilityAssessmentPhase:
    def __init__(self):
        self.output = OutputFormatter()
        
    def execute_assessment(self, vapt_module, target, session):
        """Execute interactive vulnerability assessment phase"""
        self.output.print_section_header("VULNERABILITY ASSESSMENT")
        
        va_results = {
            'target': target,
            'assessment_type': vapt_module.vapt_type,
            'vulnerabilities': [],
            'scan_results': {},
            'start_time': datetime.now().isoformat()
        }
        
        # Get available assessment tools for this VAPT type
        available_tools = vapt_module.get_vulnerability_tools()
        
        # Let user select tools to run
        selected_tools = self.select_assessment_tools(available_tools)
        
        # Execute vulnerability scans
        for tool in selected_tools:
            self.output.print_info(f"Running {tool} assessment...")
            tool_results = self.execute_tool_assessment(tool, target, vapt_module, session)
            va_results['scan_results'][tool] = tool_results
            
            # Parse and add vulnerabilities
            vulnerabilities = self.parse_tool_results(tool, tool_results, target)
            va_results['vulnerabilities'].extend(vulnerabilities)
            
        # Classify and prioritize vulnerabilities
        va_results['classified_vulnerabilities'] = self.classify_vulnerabilities(va_results['vulnerabilities'])
        
        va_results['end_time'] = datetime.now().isoformat()
        
        # Save vulnerability assessment results
        va_file = os.path.join(session['directory'], 'vulnerability_assessment.json')
        with open(va_file, 'w') as f:
            json.dump(va_results, f, indent=2)
            
        session['vulnerability_assessment'] = va_results
        self.output.print_success("Vulnerability assessment phase completed successfully!")
        
        # Display summary
        self.display_vulnerability_summary(va_results)
        
        return va_results
        
    def execute_automated_assessment(self, vapt_module, target, session):
        """Execute automated vulnerability assessment with all available tools"""
        self.output.print_info("Executing automated vulnerability assessment...")
        
        va_results = {
            'target': target,
            'assessment_type': vapt_module.vapt_type,
            'vulnerabilities': [],
            'scan_results': {},
            'start_time': datetime.now().isoformat()
        }
        
        # Get all available tools for this VAPT type
        available_tools = vapt_module.get_vulnerability_tools()
        
        # Execute all vulnerability scans
        for tool in available_tools.keys():
            self.output.print_info(f"Running automated {tool} assessment...")
            tool_results = self.execute_tool_assessment(tool, target, vapt_module, session)
            va_results['scan_results'][tool] = tool_results
            
            # Parse and add vulnerabilities
            vulnerabilities = self.parse_tool_results(tool, tool_results, target)
            va_results['vulnerabilities'].extend(vulnerabilities)
            
        # Classify and prioritize vulnerabilities
        va_results['classified_vulnerabilities'] = self.classify_vulnerabilities(va_results['vulnerabilities'])
        
        va_results['end_time'] = datetime.now().isoformat()
        
        # Save vulnerability assessment results
        va_file = os.path.join(session['directory'], 'vulnerability_assessment.json')
        with open(va_file, 'w') as f:
            json.dump(va_results, f, indent=2)
            
        session['vulnerability_assessment'] = va_results
        self.output.print_success("Automated vulnerability assessment completed!")
        
        return va_results
        
    def select_assessment_tools(self, available_tools):
        """Allow user to select which assessment tools to run"""
        self.output.print_info("Available vulnerability assessment tools:")
        
        tools_list = list(available_tools.keys())
        for i, (tool, description) in enumerate(available_tools.items(), 1):
            print(f"{i}. {tool} - {description}")
            
        print(f"\n{Fore.YELLOW}Select tools to run:{Style.RESET_ALL}")
        print("Enter tool numbers separated by commas (e.g., 1,3,5)")
        print("Enter 'all' to run all tools")
        
        choice = input(f"{Fore.CYAN}Your choice: {Style.RESET_ALL}").strip().lower()
        
        if choice == 'all':
            return tools_list
        else:
            selected_tools = []
            try:
                selections = [int(x.strip()) for x in choice.split(',')]
                for sel in selections:
                    if 1 <= sel <= len(tools_list):
                        selected_tools.append(tools_list[sel - 1])
                return selected_tools if selected_tools else tools_list
            except ValueError:
                self.output.print_warning("Invalid selection, running all tools")
                return tools_list
                
    def execute_tool_assessment(self, tool, target, vapt_module, session):
        """Execute vulnerability assessment with a specific tool"""
        tool_results = {
            'tool': tool,
            'target': target,
            'start_time': datetime.now().isoformat(),
            'status': 'running'
        }
        
        try:
            if tool == 'nmap_vuln':
                tool_results.update(self.run_nmap_vulnerability_scan(target))
            elif tool == 'nikto':
                tool_results.update(self.run_nikto_scan(target))
            elif tool == 'sqlmap':
                tool_results.update(self.run_sqlmap_scan(target))
            elif tool == 'dirb':
                tool_results.update(self.run_dirb_scan(target))
            elif tool == 'sslscan':
                tool_results.update(self.run_sslscan(target))
            elif tool == 'testssl':
                tool_results.update(self.run_testssl(target))
            elif tool == 'nuclei':
                tool_results.update(self.run_nuclei_scan(target))
            elif tool == 'custom_checks':
                tool_results.update(self.run_custom_vulnerability_checks(target, vapt_module))
            else:
                tool_results['status'] = 'unsupported'
                tool_results['error'] = f"Tool {tool} not implemented"
                
        except Exception as e:
            tool_results['status'] = 'error'
            tool_results['error'] = str(e)
            self.output.print_error(f"Error running {tool}: {str(e)}")
            
        tool_results['end_time'] = datetime.now().isoformat()
        return tool_results
        
    def run_nmap_vulnerability_scan(self, target):
        """Run nmap vulnerability scanning scripts"""
        results = {'tool': 'nmap_vuln'}
        
        try:
            hostname = self.extract_hostname(target)
            nmap_cmd = ['nmap', '--script', 'vuln', '-sV', hostname]
            
            nmap_output = subprocess.run(nmap_cmd, capture_output=True, text=True, timeout=600)
            
            if nmap_output.returncode == 0:
                results['status'] = 'completed'
                results['output'] = nmap_output.stdout
                results['vulnerabilities_found'] = self.parse_nmap_vuln_output(nmap_output.stdout)
            else:
                results['status'] = 'error'
                results['error'] = nmap_output.stderr
                
        except subprocess.TimeoutExpired:
            results['status'] = 'timeout'
            results['error'] = 'Nmap vulnerability scan timed out'
        except FileNotFoundError:
            results['status'] = 'tool_not_found'
            results['error'] = 'nmap command not found'
        except Exception as e:
            results['status'] = 'error'
            results['error'] = str(e)
            
        return results
        
    def run_nikto_scan(self, target):
        """Run Nikto web vulnerability scanner"""
        results = {'tool': 'nikto'}
        
        try:
            nikto_cmd = ['nikto', '-h', target, '-Format', 'txt']
            
            nikto_output = subprocess.run(nikto_cmd, capture_output=True, text=True, timeout=600)
            
            if nikto_output.returncode == 0:
                results['status'] = 'completed'
                results['output'] = nikto_output.stdout
                results['vulnerabilities_found'] = self.parse_nikto_output(nikto_output.stdout)
            else:
                results['status'] = 'error'
                results['error'] = nikto_output.stderr
                
        except subprocess.TimeoutExpired:
            results['status'] = 'timeout'
            results['error'] = 'Nikto scan timed out'
        except FileNotFoundError:
            results['status'] = 'tool_not_found'
            results['error'] = 'nikto command not found'
        except Exception as e:
            results['status'] = 'error'
            results['error'] = str(e)
            
        return results
        
    def run_sqlmap_scan(self, target):
        """Run SQLMap for SQL injection testing"""
        results = {'tool': 'sqlmap'}
        
        try:
            sqlmap_cmd = ['sqlmap', '-u', target, '--batch', '--level=2', '--risk=2']
            
            sqlmap_output = subprocess.run(sqlmap_cmd, capture_output=True, text=True, timeout=900)
            
            results['status'] = 'completed'
            results['output'] = sqlmap_output.stdout
            results['vulnerabilities_found'] = self.parse_sqlmap_output(sqlmap_output.stdout)
                
        except subprocess.TimeoutExpired:
            results['status'] = 'timeout'
            results['error'] = 'SQLMap scan timed out'
        except FileNotFoundError:
            results['status'] = 'tool_not_found'
            results['error'] = 'sqlmap command not found'
        except Exception as e:
            results['status'] = 'error'
            results['error'] = str(e)
            
        return results
        
    def run_dirb_scan(self, target):
        """Run DIRB directory/file brute force scanner"""
        results = {'tool': 'dirb'}
        
        try:
            dirb_cmd = ['dirb', target]
            
            dirb_output = subprocess.run(dirb_cmd, capture_output=True, text=True, timeout=600)
            
            if dirb_output.returncode == 0:
                results['status'] = 'completed'
                results['output'] = dirb_output.stdout
                results['vulnerabilities_found'] = self.parse_dirb_output(dirb_output.stdout)
            else:
                results['status'] = 'error'
                results['error'] = dirb_output.stderr
                
        except subprocess.TimeoutExpired:
            results['status'] = 'timeout'
            results['error'] = 'DIRB scan timed out'
        except FileNotFoundError:
            results['status'] = 'tool_not_found'
            results['error'] = 'dirb command not found'
        except Exception as e:
            results['status'] = 'error'
            results['error'] = str(e)
            
        return results
        
    def run_sslscan(self, target):
        """Run SSLScan for SSL/TLS vulnerability assessment"""
        results = {'tool': 'sslscan'}
        
        try:
            hostname = self.extract_hostname(target)
            sslscan_cmd = ['sslscan', hostname]
            
            sslscan_output = subprocess.run(sslscan_cmd, capture_output=True, text=True, timeout=300)
            
            if sslscan_output.returncode == 0:
                results['status'] = 'completed'
                results['output'] = sslscan_output.stdout
                results['vulnerabilities_found'] = self.parse_sslscan_output(sslscan_output.stdout)
            else:
                results['status'] = 'error'
                results['error'] = sslscan_output.stderr
                
        except subprocess.TimeoutExpired:
            results['status'] = 'timeout'
            results['error'] = 'SSLScan timed out'
        except FileNotFoundError:
            results['status'] = 'tool_not_found'
            results['error'] = 'sslscan command not found'
        except Exception as e:
            results['status'] = 'error'
            results['error'] = str(e)
            
        return results
        
    def run_testssl(self, target):
        """Run testssl.sh for comprehensive SSL/TLS testing"""
        results = {'tool': 'testssl'}
        
        try:
            hostname = self.extract_hostname(target)
            testssl_cmd = ['testssl.sh', '--quiet', hostname]
            
            testssl_output = subprocess.run(testssl_cmd, capture_output=True, text=True, timeout=600)
            
            results['status'] = 'completed'
            results['output'] = testssl_output.stdout
            results['vulnerabilities_found'] = self.parse_testssl_output(testssl_output.stdout)
                
        except subprocess.TimeoutExpired:
            results['status'] = 'timeout'
            results['error'] = 'testssl.sh timed out'
        except FileNotFoundError:
            results['status'] = 'tool_not_found'
            results['error'] = 'testssl.sh not found'
        except Exception as e:
            results['status'] = 'error'
            results['error'] = str(e)
            
        return results
        
    def run_nuclei_scan(self, target):
        """Run Nuclei vulnerability scanner"""
        results = {'tool': 'nuclei'}
        
        try:
            nuclei_cmd = ['nuclei', '-u', target, '-severity', 'low,medium,high,critical']
            
            nuclei_output = subprocess.run(nuclei_cmd, capture_output=True, text=True, timeout=600)
            
            if nuclei_output.returncode == 0:
                results['status'] = 'completed'
                results['output'] = nuclei_output.stdout
                results['vulnerabilities_found'] = self.parse_nuclei_output(nuclei_output.stdout)
            else:
                results['status'] = 'error'
                results['error'] = nuclei_output.stderr
                
        except subprocess.TimeoutExpired:
            results['status'] = 'timeout'
            results['error'] = 'Nuclei scan timed out'
        except FileNotFoundError:
            results['status'] = 'tool_not_found'
            results['error'] = 'nuclei command not found'
        except Exception as e:
            results['status'] = 'error'
            results['error'] = str(e)
            
        return results
        
    def run_custom_vulnerability_checks(self, target, vapt_module):
        """Run custom vulnerability checks specific to the VAPT type"""
        results = {'tool': 'custom_checks'}
        vulnerabilities = []
        
        try:
            if vapt_module.vapt_type == 'web':
                vulnerabilities.extend(self.check_web_vulnerabilities(target))
            elif vapt_module.vapt_type == 'api':
                vulnerabilities.extend(self.check_api_vulnerabilities(target))
            elif vapt_module.vapt_type == 'network':
                vulnerabilities.extend(self.check_network_vulnerabilities(target))
            elif vapt_module.vapt_type == 'cloud':
                vulnerabilities.extend(self.check_cloud_vulnerabilities(target))
                
            results['status'] = 'completed'
            results['vulnerabilities_found'] = vulnerabilities
            
        except Exception as e:
            results['status'] = 'error'
            results['error'] = str(e)
            
        return results
        
    def check_web_vulnerabilities(self, target):
        """Custom web application vulnerability checks"""
        vulnerabilities = []
        
        try:
            # Check for common web vulnerabilities
            response = requests.get(target, timeout=10)
            headers = response.headers
            
            # Security headers check
            security_headers = [
                'X-Frame-Options', 'X-Content-Type-Options', 'X-XSS-Protection',
                'Strict-Transport-Security', 'Content-Security-Policy'
            ]
            
            for header in security_headers:
                if header not in headers:
                    vulnerabilities.append({
                        'type': 'Missing Security Header',
                        'severity': 'Medium',
                        'description': f'Missing {header} header',
                        'location': target
                    })
            
            # Check for information disclosure
            if 'Server' in headers:
                vulnerabilities.append({
                    'type': 'Information Disclosure',
                    'severity': 'Low',
                    'description': f'Server banner disclosed: {headers["Server"]}',
                    'location': target
                })
                
        except Exception as e:
            pass
            
        return vulnerabilities
        
    def check_api_vulnerabilities(self, target):
        """Custom API vulnerability checks"""
        vulnerabilities = []
        
        try:
            # Check for common API vulnerabilities
            response = requests.get(target, timeout=10)
            
            # Check for API versioning
            if '/v1/' not in target and '/v2/' not in target and '/api/' not in target:
                vulnerabilities.append({
                    'type': 'API Design Issue',
                    'severity': 'Low',
                    'description': 'API endpoint lacks version information',
                    'location': target
                })
                
            # Check for excessive data exposure
            if response.status_code == 200:
                try:
                    data = response.json()
                    if isinstance(data, dict) and len(data.keys()) > 20:
                        vulnerabilities.append({
                            'type': 'Excessive Data Exposure',
                            'severity': 'Medium',
                            'description': 'API returns excessive amount of data',
                            'location': target
                        })
                except:
                    pass
                    
        except Exception as e:
            pass
            
        return vulnerabilities
        
    def check_network_vulnerabilities(self, target):
        """Custom network vulnerability checks"""
        vulnerabilities = []
        
        try:
            import socket
            hostname = self.extract_hostname(target)
            
            # Check for common insecure services
            insecure_ports = {
                21: 'FTP - Unencrypted file transfer',
                23: 'Telnet - Unencrypted remote access',
                25: 'SMTP - Potentially unencrypted email',
                53: 'DNS - Check for zone transfer',
                79: 'Finger - Information disclosure service',
                135: 'RPC - Windows RPC service'
            }
            
            for port, description in insecure_ports.items():
                try:
                    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                    sock.settimeout(2)
                    result = sock.connect_ex((hostname, port))
                    if result == 0:
                        vulnerabilities.append({
                            'type': 'Insecure Service',
                            'severity': 'Medium',
                            'description': description,
                            'location': f'{hostname}:{port}'
                        })
                    sock.close()
                except:
                    pass
                    
        except Exception as e:
            pass
            
        return vulnerabilities
        
    def check_cloud_vulnerabilities(self, target):
        """Custom cloud vulnerability checks"""
        vulnerabilities = []
        
        try:
            # Check for common cloud misconfigurations
            response = requests.get(target, timeout=10)
            
            # Check for cloud storage buckets
            if 's3.amazonaws.com' in target or 'storage.googleapis.com' in target:
                if response.status_code == 200:
                    vulnerabilities.append({
                        'type': 'Public Cloud Storage',
                        'severity': 'High',
                        'description': 'Cloud storage bucket is publicly accessible',
                        'location': target
                    })
                    
        except Exception as e:
            pass
            
        return vulnerabilities
        
    def parse_tool_results(self, tool, tool_results, target):
        """Parse tool results and extract vulnerabilities"""
        vulnerabilities = []
        
        if 'vulnerabilities_found' in tool_results:
            for vuln in tool_results['vulnerabilities_found']:
                vuln['tool'] = tool
                vuln['target'] = target
                vulnerabilities.append(vuln)
                
        return vulnerabilities
        
    def parse_nmap_vuln_output(self, output):
        """Parse nmap vulnerability scan output"""
        vulnerabilities = []
        lines = output.split('\n')
        
        current_vuln = None
        for line in lines:
            line = line.strip()
            if 'VULNERABLE:' in line:
                current_vuln = {
                    'type': 'Network Vulnerability',
                    'severity': 'Medium',
                    'description': line.replace('VULNERABLE:', '').strip(),
                    'tool_output': line
                }
            elif current_vuln and line.startswith('|'):
                current_vuln['tool_output'] += '\n' + line
            elif current_vuln and not line.startswith('|') and line:
                vulnerabilities.append(current_vuln)
                current_vuln = None
                
        if current_vuln:
            vulnerabilities.append(current_vuln)
            
        return vulnerabilities
        
    def parse_nikto_output(self, output):
        """Parse Nikto scan output"""
        vulnerabilities = []
        lines = output.split('\n')
        
        for line in lines:
            if '+' in line and ('OSVDB' in line or 'CVE' in line or 'error' in line.lower()):
                vulnerabilities.append({
                    'type': 'Web Vulnerability',
                    'severity': 'Medium',
                    'description': line.strip(),
                    'tool_output': line
                })
                
        return vulnerabilities
        
    def parse_sqlmap_output(self, output):
        """Parse SQLMap output"""
        vulnerabilities = []
        
        if 'vulnerable' in output.lower():
            vulnerabilities.append({
                'type': 'SQL Injection',
                'severity': 'High',
                'description': 'SQL injection vulnerability detected',
                'tool_output': output
            })
            
        return vulnerabilities
        
    def parse_dirb_output(self, output):
        """Parse DIRB output"""
        vulnerabilities = []
        lines = output.split('\n')
        
        for line in lines:
            if '==> DIRECTORY:' in line or '+ ' in line:
                if 'admin' in line.lower() or 'config' in line.lower() or 'backup' in line.lower():
                    vulnerabilities.append({
                        'type': 'Sensitive Directory',
                        'severity': 'Medium',
                        'description': f'Sensitive directory found: {line.strip()}',
                        'tool_output': line
                    })
                    
        return vulnerabilities
        
    def parse_sslscan_output(self, output):
        """Parse SSLScan output"""
        vulnerabilities = []
        lines = output.split('\n')
        
        for line in lines:
            if 'VULNERABLE' in line or 'weak' in line.lower():
                vulnerabilities.append({
                    'type': 'SSL/TLS Vulnerability',
                    'severity': 'Medium',
                    'description': line.strip(),
                    'tool_output': line
                })
                
        return vulnerabilities
        
    def parse_testssl_output(self, output):
        """Parse testssl.sh output"""
        vulnerabilities = []
        lines = output.split('\n')
        
        for line in lines:
            if 'VULNERABLE' in line or 'NOT ok' in line:
                vulnerabilities.append({
                    'type': 'SSL/TLS Issue',
                    'severity': 'Medium',
                    'description': line.strip(),
                    'tool_output': line
                })
                
        return vulnerabilities
        
    def parse_nuclei_output(self, output):
        """Parse Nuclei output"""
        vulnerabilities = []
        lines = output.split('\n')
        
        for line in lines:
            if '[' in line and ']' in line:
                parts = line.split(']')
                if len(parts) >= 2:
                    severity = 'Medium'
                    if 'critical' in line.lower():
                        severity = 'Critical'
                    elif 'high' in line.lower():
                        severity = 'High'
                    elif 'low' in line.lower():
                        severity = 'Low'
                        
                    vulnerabilities.append({
                        'type': 'Security Issue',
                        'severity': severity,
                        'description': line.strip(),
                        'tool_output': line
                    })
                    
        return vulnerabilities
        
    def classify_vulnerabilities(self, vulnerabilities):
        """Classify and prioritize vulnerabilities"""
        classified = {
            'critical': [],
            'high': [],
            'medium': [],
            'low': [],
            'informational': []
        }
        
        for vuln in vulnerabilities:
            severity = vuln.get('severity', 'Medium').lower()
            if severity in classified:
                classified[severity].append(vuln)
            else:
                classified['medium'].append(vuln)
                
        return classified
        
    def display_vulnerability_summary(self, va_results):
        """Display a summary of discovered vulnerabilities"""
        self.output.print_section_header("VULNERABILITY ASSESSMENT SUMMARY")
        
        classified = va_results.get('classified_vulnerabilities', {})
        
        total_vulns = sum(len(vulns) for vulns in classified.values())
        
        print(f"{Fore.CYAN}Total vulnerabilities found: {total_vulns}{Style.RESET_ALL}\n")
        
        severity_colors = {
            'critical': Fore.MAGENTA,
            'high': Fore.RED,
            'medium': Fore.YELLOW,
            'low': Fore.BLUE,
            'informational': Fore.WHITE
        }
        
        for severity, vulns in classified.items():
            if vulns:
                color = severity_colors.get(severity, Fore.WHITE)
                print(f"{color}{severity.capitalize()}: {len(vulns)} vulnerabilities{Style.RESET_ALL}")
                
                # Show first few vulnerabilities
                for i, vuln in enumerate(vulns[:3]):
                    print(f"  - {vuln.get('type', 'Unknown')}: {vuln.get('description', 'No description')[:80]}...")
                    
                if len(vulns) > 3:
                    print(f"  ... and {len(vulns) - 3} more")
                print()
                
    def extract_hostname(self, target):
        """Extract hostname/IP from target"""
        if target.startswith('http'):
            from urllib.parse import urlparse
            parsed = urlparse(target)
            return parsed.netloc.split(':')[0]
        elif '/' in target:
            return target.split('/')[0]
        else:
            return target.split(':')[0]
