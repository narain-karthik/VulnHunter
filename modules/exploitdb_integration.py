"""
Exploit-DB Integration Module
Provides integration with Exploit-DB for CVE-based exploit discovery and manual testing guidance
"""

import os
import json
import subprocess
import requests
import tempfile
import sqlite3
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Tuple
from colorama import Fore, Style
from utils.output_formatter import OutputFormatter

class ExploitDBIntegration:
    def __init__(self):
        self.output = OutputFormatter()
        self.searchsploit_available = self.check_searchsploit_availability()
        self.cache_dir = os.path.join(os.getcwd(), '.exploitdb_cache')
        self.cache_duration = 7  # days
        self.create_cache_directory()
        
    def check_searchsploit_availability(self) -> bool:
        """Check if searchsploit tool is available"""
        try:
            result = subprocess.run(['searchsploit', '--help'], 
                                 capture_output=True, text=True, timeout=10)
            return result.returncode == 0
        except (subprocess.TimeoutExpired, FileNotFoundError):
            return False
            
    def create_cache_directory(self):
        """Create cache directory for storing exploit data"""
        os.makedirs(self.cache_dir, exist_ok=True)
        
    def search_exploits_by_cve(self, cve_id: str) -> List[Dict]:
        """Search for exploits by CVE identifier"""
        self.output.print_info(f"Searching Exploit-DB for CVE: {cve_id}")
        
        # Try cache first
        cached_results = self.get_cached_results(cve_id)
        if cached_results:
            self.output.print_success(f"Found {len(cached_results)} cached exploits for {cve_id}")
            return cached_results
            
        exploits = []
        
        # Method 1: Use searchsploit if available
        if self.searchsploit_available:
            exploits.extend(self.search_with_searchsploit(cve_id))
            
        # Method 2: Web scraping fallback
        if not exploits:
            exploits.extend(self.search_web_interface(cve_id))
            
        # Cache results
        if exploits:
            self.cache_results(cve_id, exploits)
            
        return exploits
        
    def search_with_searchsploit(self, cve_id: str) -> List[Dict]:
        """Search using searchsploit command-line tool"""
        exploits = []
        
        try:
            # Search by CVE
            cmd = ['searchsploit', '--cve', cve_id, '-j']
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=30)
            
            if result.returncode == 0 and result.stdout.strip():
                data = json.loads(result.stdout)
                
                for exploit in data.get('RESULTS_EXPLOIT', []):
                    exploit_info = {
                        'id': exploit.get('EDB-ID', 'Unknown'),
                        'title': exploit.get('Title', 'Unknown'),
                        'type': exploit.get('Type', 'Unknown'),
                        'platform': exploit.get('Platform', 'Unknown'),
                        'author': exploit.get('Author', 'Unknown'),
                        'date': exploit.get('Date', 'Unknown'),
                        'path': exploit.get('Path', ''),
                        'cve': cve_id,
                        'source': 'Exploit-DB',
                        'download_url': f"https://www.exploit-db.com/download/{exploit.get('EDB-ID', '')}",
                        'web_url': f"https://www.exploit-db.com/exploits/{exploit.get('EDB-ID', '')}",
                        'verified': exploit.get('Verified', False),
                        'risk_level': self.determine_risk_level(exploit.get('Type', '')),
                        'methodology': self.get_exploit_methodology(exploit.get('Type', '')),
                        'manual_steps': self.get_manual_testing_steps(exploit),
                        'tools_required': self.get_required_tools(exploit),
                        'detection_indicators': self.get_detection_indicators(exploit),
                        'impact': self.get_potential_impact(exploit)
                    }
                    exploits.append(exploit_info)
                    
        except (subprocess.TimeoutExpired, json.JSONDecodeError, Exception) as e:
            self.output.print_warning(f"SearchSploit search failed: {str(e)}")
            
        return exploits
        
    def search_web_interface(self, cve_id: str) -> List[Dict]:
        """Search Exploit-DB web interface as fallback"""
        exploits = []
        
        try:
            # Search URL for CVE
            search_url = f"https://www.exploit-db.com/search?cve={cve_id}"
            headers = {
                'User-Agent': 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
            }
            
            response = requests.get(search_url, headers=headers, timeout=15)
            
            if response.status_code == 200:
                # Parse basic information from web response
                # Note: This is a simplified parser - in production, you'd want more robust parsing
                content = response.text
                
                if cve_id.upper() in content.upper():
                    # Basic exploit found indicator
                    exploit_info = {
                        'id': 'Web-Search',
                        'title': f'Exploit found for {cve_id}',
                        'type': 'Unknown',
                        'platform': 'Multiple',
                        'author': 'Various',
                        'date': datetime.now().strftime('%Y-%m-%d'),
                        'cve': cve_id,
                        'source': 'Exploit-DB Web',
                        'web_url': search_url,
                        'verified': False,
                        'risk_level': 'medium',
                        'methodology': 'Manual web search verification required',
                        'manual_steps': [
                            f"1. Visit {search_url}",
                            "2. Review available exploits manually",
                            "3. Download relevant proof-of-concept code",
                            "4. Adapt exploit for target environment",
                            "5. Test in controlled environment first"
                        ],
                        'tools_required': ['web browser', 'text editor'],
                        'detection_indicators': ['Exploit execution success', 'Target system compromise'],
                        'impact': 'Varies by CVE severity and exploit type'
                    }
                    exploits.append(exploit_info)
                    
        except requests.RequestException as e:
            self.output.print_warning(f"Web interface search failed: {str(e)}")
            
        return exploits
        
    def determine_risk_level(self, exploit_type: str) -> str:
        """Determine risk level based on exploit type"""
        high_risk_types = ['remote', 'dos', 'code execution', 'buffer overflow']
        medium_risk_types = ['local', 'privilege escalation', 'sql injection']
        
        exploit_type_lower = exploit_type.lower()
        
        if any(risk_type in exploit_type_lower for risk_type in high_risk_types):
            return 'high'
        elif any(risk_type in exploit_type_lower for risk_type in medium_risk_types):
            return 'medium'
        else:
            return 'low'
            
    def get_exploit_methodology(self, exploit_type: str) -> str:
        """Get methodology description based on exploit type"""
        methodologies = {
            'remote': 'Remote code execution through network services',
            'local': 'Local privilege escalation on compromised system',
            'webapps': 'Web application vulnerability exploitation',
            'dos': 'Denial of service attack execution',
            'buffer overflow': 'Memory corruption exploitation techniques',
            'sql injection': 'Database query manipulation and data extraction'
        }
        
        for key, method in methodologies.items():
            if key in exploit_type.lower():
                return method
                
        return 'Review exploit code and adapt for target environment'
        
    def get_manual_testing_steps(self, exploit: Dict) -> List[str]:
        """Generate manual testing steps based on exploit information"""
        exploit_type = exploit.get('Type', '').lower()
        
        if 'remote' in exploit_type:
            return [
                "1. Identify target service version and confirm vulnerability",
                "2. Download and review exploit code from Exploit-DB",
                "3. Set up testing environment matching target",
                "4. Modify exploit for target IP/hostname",
                "5. Test exploit in controlled environment first",
                "6. Execute exploit against target with proper authorization",
                "7. Document successful exploitation and impact"
            ]
        elif 'webapps' in exploit_type:
            return [
                "1. Identify vulnerable web application version",
                "2. Review exploit proof-of-concept code",
                "3. Set up local testing environment",
                "4. Modify payloads for target application",
                "5. Test for input validation bypasses",
                "6. Execute exploit through web interface",
                "7. Verify successful exploitation and document findings"
            ]
        elif 'local' in exploit_type:
            return [
                "1. Gain initial access to target system",
                "2. Confirm vulnerable software version",
                "3. Download and compile exploit if needed",
                "4. Transfer exploit to target system",
                "5. Execute privilege escalation exploit",
                "6. Verify elevated privileges obtained",
                "7. Document privilege escalation path"
            ]
        else:
            return [
                "1. Study exploit code and requirements",
                "2. Set up appropriate testing environment",
                "3. Adapt exploit for target specifics",
                "4. Test in controlled environment",
                "5. Execute against authorized target",
                "6. Document results and impact"
            ]
            
    def get_required_tools(self, exploit: Dict) -> List[str]:
        """Determine required tools based on exploit type"""
        exploit_type = exploit.get('Type', '').lower()
        platform = exploit.get('Platform', '').lower()
        
        tools = ['text editor', 'terminal']
        
        if 'remote' in exploit_type:
            tools.extend(['netcat', 'nmap', 'python3'])
        if 'webapps' in exploit_type:
            tools.extend(['curl', 'burpsuite', 'browser'])
        if 'local' in exploit_type:
            tools.extend(['gcc', 'make', 'file transfer tool'])
        if 'python' in platform:
            tools.append('python3')
        if 'php' in platform:
            tools.append('php')
        if 'windows' in platform:
            tools.extend(['powershell', 'cmd'])
        if 'linux' in platform:
            tools.extend(['bash', 'chmod'])
            
        return list(set(tools))  # Remove duplicates
        
    def get_detection_indicators(self, exploit: Dict) -> List[str]:
        """Get indicators of successful exploitation"""
        exploit_type = exploit.get('Type', '').lower()
        
        if 'remote' in exploit_type:
            return [
                'Remote shell/command execution',
                'Network connection established',
                'Service crash or restart',
                'Unusual network traffic'
            ]
        elif 'webapps' in exploit_type:
            return [
                'Successful payload execution',
                'Unauthorized data access',
                'Application error messages',
                'Session hijacking success'
            ]
        elif 'local' in exploit_type:
            return [
                'Privilege escalation success',
                'Root/admin access obtained',
                'System file access',
                'Process execution as elevated user'
            ]
        else:
            return [
                'Exploit execution success',
                'Target system compromise',
                'Unauthorized access obtained'
            ]
            
    def get_potential_impact(self, exploit: Dict) -> str:
        """Determine potential impact based on exploit type"""
        exploit_type = exploit.get('Type', '').lower()
        
        if 'remote' in exploit_type:
            return 'Complete system compromise, remote code execution, data theft'
        elif 'local' in exploit_type:
            return 'Privilege escalation, system administration access, data access'
        elif 'webapps' in exploit_type:
            return 'Data breach, session hijacking, application compromise'
        elif 'dos' in exploit_type:
            return 'Service disruption, system unavailability, resource exhaustion'
        else:
            return 'Varies by exploit type and target environment'
            
    def get_cached_results(self, cve_id: str) -> Optional[List[Dict]]:
        """Get cached exploit results if available and fresh"""
        cache_file = os.path.join(self.cache_dir, f"{cve_id}.json")
        
        if not os.path.exists(cache_file):
            return None
            
        try:
            with open(cache_file, 'r') as f:
                cache_data = json.load(f)
                
            # Check cache age
            cache_time = datetime.fromisoformat(cache_data['timestamp'])
            if datetime.now() - cache_time > timedelta(days=self.cache_duration):
                return None
                
            return cache_data['exploits']
            
        except (json.JSONDecodeError, KeyError, ValueError):
            return None
            
    def cache_results(self, cve_id: str, exploits: List[Dict]):
        """Cache exploit search results"""
        cache_file = os.path.join(self.cache_dir, f"{cve_id}.json")
        
        cache_data = {
            'timestamp': datetime.now().isoformat(),
            'cve_id': cve_id,
            'exploits': exploits
        }
        
        try:
            with open(cache_file, 'w') as f:
                json.dump(cache_data, f, indent=2)
        except Exception as e:
            self.output.print_warning(f"Failed to cache results: {str(e)}")
            
    def get_exploit_by_id(self, exploit_id: str) -> Optional[Dict]:
        """Get specific exploit by Exploit-DB ID"""
        try:
            if self.searchsploit_available:
                cmd = ['searchsploit', '-i', exploit_id]
                result = subprocess.run(cmd, capture_output=True, text=True, timeout=15)
                
                if result.returncode == 0:
                    # Parse searchsploit output for exploit details
                    return {
                        'id': exploit_id,
                        'details': result.stdout,
                        'source': 'SearchSploit',
                        'web_url': f"https://www.exploit-db.com/exploits/{exploit_id}",
                        'download_url': f"https://www.exploit-db.com/download/{exploit_id}"
                    }
                    
        except Exception as e:
            self.output.print_warning(f"Failed to get exploit {exploit_id}: {str(e)}")
            
        return None
        
    def download_exploit_code(self, exploit_id: str, output_dir: str = None) -> Optional[str]:
        """Download exploit code from Exploit-DB"""
        if not output_dir:
            output_dir = tempfile.gettempdir()
            
        try:
            download_url = f"https://www.exploit-db.com/download/{exploit_id}"
            response = requests.get(download_url, timeout=30)
            
            if response.status_code == 200:
                filename = f"exploit_{exploit_id}.txt"
                filepath = os.path.join(output_dir, filename)
                
                with open(filepath, 'w', encoding='utf-8') as f:
                    f.write(response.text)
                    
                self.output.print_success(f"Downloaded exploit code to: {filepath}")
                return filepath
                
        except Exception as e:
            self.output.print_error(f"Failed to download exploit {exploit_id}: {str(e)}")
            
        return None
        
    def get_recent_exploits(self, days: int = 7) -> List[Dict]:
        """Get recent exploits from the last N days"""
        exploits = []
        
        try:
            # Use web interface to get recent exploits
            search_url = "https://www.exploit-db.com/"
            headers = {
                'User-Agent': 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36'
            }
            
            response = requests.get(search_url, headers=headers, timeout=15)
            
            if response.status_code == 200:
                # This would require proper HTML parsing in production
                # For now, return a placeholder indicating recent exploits are available
                exploits.append({
                    'info': f'Recent exploits from last {days} days available at {search_url}',
                    'manual_steps': [
                        f"1. Visit {search_url}",
                        "2. Review recent exploit entries",
                        "3. Filter by relevant platforms/types",
                        "4. Download applicable proof-of-concepts"
                    ]
                })
                
        except Exception as e:
            self.output.print_warning(f"Failed to get recent exploits: {str(e)}")
            
        return exploits
        
    def display_exploit_summary(self, exploits: List[Dict]):
        """Display a summary of found exploits"""
        if not exploits:
            self.output.print_info("No exploits found in Exploit-DB")
            return
            
        self.output.print_section_header("EXPLOIT-DB SEARCH RESULTS")
        
        for i, exploit in enumerate(exploits, 1):
            risk_color = Fore.GREEN if exploit.get('risk_level') == 'low' else Fore.YELLOW if exploit.get('risk_level') == 'medium' else Fore.RED
            
            print(f"\n{Fore.CYAN}[{i}] {exploit.get('title', 'Unknown')}{Style.RESET_ALL}")
            print(f"    ID: {exploit.get('id', 'N/A')}")
            print(f"    Type: {exploit.get('type', 'Unknown')}")
            print(f"    Platform: {exploit.get('platform', 'Unknown')}")
            print(f"    Risk Level: {risk_color}{exploit.get('risk_level', 'unknown').upper()}{Style.RESET_ALL}")
            print(f"    Author: {exploit.get('author', 'Unknown')}")
            print(f"    Date: {exploit.get('date', 'Unknown')}")
            
            if exploit.get('web_url'):
                print(f"    URL: {exploit.get('web_url')}")
                
            if exploit.get('methodology'):
                print(f"    Method: {exploit.get('methodology')}")
                
        print(f"\n{Fore.YELLOW}Found {len(exploits)} exploit(s) in Exploit-DB{Style.RESET_ALL}")
        print(f"{Fore.CYAN}Use 'guide' option during exploit selection to see detailed instructions{Style.RESET_ALL}")